# Метрополитен состоит из нескольких линий метро. Все станции метро в городе пронумерованы натуральными числами от 1 до N. На каждой линии расположено 
# несколько станций. Если одна и та же станция расположена сразу на нескольких линиях, то она является станцией пересадки и на этой станции можно пересесть 
# с любой линии, которая через нее проходит, на любую другую (опять же проходящую через нее).

# Напишите программу, которая по данному вам описанию метрополитена определит, с каким минимальным числом пересадок можно добраться со станции A на станцию 
# B. Если данный метрополитен не соединяет все линии в одну систему, то может так получиться, что со станции A на станцию B добраться невозможно, в этом 
# случае ваша программа должна это определить.

# Формат ввода
# Сначала вводится число N — количество станций метро в городе (2≤N≤100). Далее следует число M — количество линий метро (1≤M≤20). Далее идет описание M 
# линий. Описание каждой линии состоит из числа Pi — количество станций на этой линии (2≤Pi≤50) и Pi чисел, задающих номера станций, через которые проходит 
# линия (ни через какую станцию линия не проходит дважды).

# Затем вводятся два различных числа: A — номер начальной станции, и B — номер станции, на которую нам нужно попасть. При этом если через станцию A проходит 
# несколько линий, то мы можем спуститься на любую из них. Так же если через станцию B проходит несколько линий, то нам не важно, по какой линии мы приедем.

# Формат вывода
# Выведите минимальное количество пересадок, которое нам понадобится. Если добраться со станции A на станцию B невозможно, программа должна вывести одно 
# число –1 (минус один).

from collections import deque

n = int(input())
m = int(input())

# Создаем список списков с номерами станций на каждой линии
lines = []
for i in range(m):
    line = list(map(int, input().split()))[1:]
    lines.append(line)

# Создаем словарь, в котором для каждой станции хранится список кортежей (номер линии, индекс станции на линии)
stations = {}
for i in range(m):
    for j, station in enumerate(lines[i]):
        if station not in stations:
            stations[station] = []
        stations[station].append((i, j))

# BFS для поиска кратчайшего пути между станциями
def bfs(start, end):
    queue = deque([(start, 0)])
    visited = set([start])
    while queue:
        station, distance = queue.popleft()
        if station == end:
            return distance
        for line, station_index in stations[station]:
            for next_station_index in range(station_index+1, len(lines[line])):
                next_station = lines[line][next_station_index]
                if next_station not in visited:
                    visited.add(next_station)
                    queue.append((next_station, distance + 1))
            for next_station_index in range(station_index-1, -1, -1):
                next_station = lines[line][next_station_index]
                if next_station not in visited:
                    visited.add(next_station)
                    queue.append((next_station, distance + 1))
    return -1  # Не нашли путь

# Читаем номера начальной и конечной станций
a, b = map(int, input().split())

if bfs(a, b) < 0:
	print(-1)
else:
	print(bfs(a, b) - 1)
