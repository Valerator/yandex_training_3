// Диего увлекается коллекционированием наклеек. На каждой из них написано число, и каждый коллекционер мечтает собрать наклейки со всеми встречающимися 
// числами.

// Диего собрал N наклеек, некоторые из которых, возможно, совпадают. Как-то раз к нему пришли K коллекционеров. i-й из них собрал все наклейки с номерами
// не меньшими, чем pi. Напишите программу, которая поможет каждому из коллекционеров определить, сколько недостающих ему наклеек есть у Диего. Разумеется, 
// гостей Диего не интересуют повторные экземпляры наклеек.

// Формат ввода
// В первой строке содержится единственное число N (0 ≤ N ≤ 100 000) — количество наклеек у Диего.

// В следующей строке содержатся N целых неотрицательных чисел (не обязательно различных) — номера наклеек Диего. Все номера наклеек не превосходят 109.

// В следующей строке содержится число K (0 ≤ K ≤ 100 000) — количество коллекционеров, пришедших к Диего. В следующей строке содержатся K целых чисел 
// pi (0 ≤ pi ≤ 109), где pi — наименьший номер наклейки, не интересующий i-го коллекционера.

// Формат вывода
// Для каждого коллекционера в отдельной строке выведите количество различных чисел на наклейках, которые есть у Диего, но нет у этого коллекционера.

#include <iostream>
#include <map>

void filling_set(const unsigned N, std::map<unsigned, unsigned> &s) {
    for(size_t i = 0; i < N; i++) {
        unsigned element;
        std::cin >> element;
        s[element] = 0;
    }
    unsigned c = 1;
    for(auto& i: s) {
        i.second = c;
        ++c;
    }
}

void foo(const unsigned K, const std::map<unsigned, unsigned> &s) {
    for(size_t i = 0; i < K; i++) {
        unsigned a;
        std::cin >> a;
        auto it = s.lower_bound(a);
        if(it == s.end()) {
            std::cout << s.size() << std::endl;
        } else{
            std::cout << it->second - 1 << std::endl;
        }
    }
}



int main() {
    unsigned N;
    std::cin >> N;
    std::map<unsigned, unsigned> s;
    filling_set(N, s);
    unsigned K;
    std::cin >> K;
    foo(K, s);
}
